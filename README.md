# Reactive Programming
#### Japanese translation of wikipedia reactive-programming

English: https://en.wikipedia.org/wiki/Reactive_programming

リアクティブプログラミングは、データストリームと変化の伝播に関係する宣言的なプログラミングパラダイムである。このパラダイムでは、静的（配列など）または動的（イベントエミッタなど）なデータストリームを簡単に表現することができ、また関連する実行モデル内の推論された依存関係が存在することを伝え、変更されたデータフローの自動伝播を容易にする[citation needed] 。

一方、リアクティブプログラミングでは、bやcの値が変わるたびにaの値が自動的に更新され、プログラムが明示的にa := b + cという文を再実行しなくても、現在割り当てられたaの値が決定される[citation needed]。

```c
var b = 1
var c = 2
var a = b + c
b = 10
console.log(a) // 3 (not 12 because "=" is not a reactive assignment operator)

// now imagine you have a special operator "$=" that changes the value of a variable (executes code on the right side of the operator and assigns result to left side variable) not only when explicitly initialized, but also when referenced variables (on the right side of the operator) are changed
var b = 1
var c = 2
var a $= b + c
b = 10
console.log(a) // 12
```

また、Verilogのようなハードウェア記述言語では、リアクティブプログラミングにより、変更が回路を伝搬する際にモデル化することができます[引用者注釈]。

リアクティブプログラミングは、インタラクティブなユーザーインターフェイスや、リアルタイムに近いシステムアニメーションの作成を簡略化する方法として提案されている[引用者注釈]。

例えば、モデル・ビュー・コントローラー（MVC）アーキテクチャでは、リアクティブプログラミングによって、基礎となるモデルの変更を関連するビューに自動的に反映させることができる[1]。

## リアクティブプログラミング言語の実現に向けた取り組み

リアクティブプログラミング言語の作成には、いくつかの一般的なアプローチが採用されています。様々なドメイン制約に特化した専用言語の仕様化。このような制約は通常、リアルタイム、組み込みコンピューティング、またはハードウェアの記述によって特徴付けられる。もう一つのアプローチは、反応性のサポートを含む汎用言語の仕様化である。他のアプローチは、プログラミング言語と並行して、またはプログラミング言語の上に反応性を可能にするプログラミング・ライブラリ、または組み込みドメイン固有言語の定義と使用で明確にされます。これらの異なるアプローチの仕様と使用は、言語能力のトレードオフをもたらします。一般に、言語が制限されればされるほど、関連するコンパイラや解析ツールは開発者に情報を提供できるようになる（例えば、プログラムが実際のリアルタイムで実行できるかどうかの解析を実行する場合など）。特異性の機能的トレードオフは、言語の一般的な適用性を低下させる可能性がある。

## プログラミング・モデルとセマンティクス

リアクティブ・プログラミングには、さまざまなモデルとセマンティクスが存在する。それらを以下のような次元で緩やかに分けることができる。

- 同期性：時間の同期モデルと非同期モデル
- 決定論：決定論的な評価過程と非決定論的な評価結果
- 更新処理：コールバック、データフロー、アクター

## 実装のテクニックと課題

### インプリメンテーションのエッセンス

リアクティブプログラミング言語のランタイムは、関係するリアクティブな値間の依存関係を明らかにするグラフで表現される。このようなグラフでは、ノードは計算行為を表し、エッジは依存関係をモデル化する。このようなランタイムは、関係する入力の値が変わると新たに実行しなければならない様々な計算を追跡するために、このグラフを使用します。

### チェンジプロパガンダのアルゴリズム

データ伝播の最も一般的なアプローチは以下の通りです。

- Pull： 値コンシューマは、観測されたソースに定期的に値を問い合わせ、関連する値が利用可能になるたびに反応するという点で、実際にはプロアクティブである。イベントや値の変化を定期的にチェックするこのやり方は、一般にポーリングと呼ばれる。
- Push: 値消費者は、値が利用可能になるたびに、ソースから値を受け取る。これらの値は自己完結型であり、例えば必要な情報がすべて含まれているため、消費者がそれ以上の情報を照会する必要はない。
- Push-Pull: これは、例えば「ある値が変更された」というような、変更の短い説明であり、これはプッシュ部分である。しかし、通知には必要な情報がすべて含まれていない（つまり、実際の値が含まれていない）ため、消費者は通知を受け取った後、ソースに詳細な情報（特定の値）を問い合わせる必要があります。この方法は、消費者が潜在的に興味を持つ可能性のあるデータが大量にある場合によく使われます。そのため、スループットとレイテンシーを減らすために、軽量な通知のみを送信し、より多くの情報を必要とするコンシューマが特定の情報を要求することになります。このアプローチには、通知が送信された後、追加情報を求める多くのリクエストによってソースが圧倒されるかもしれないという欠点もあります。

### 何をPushするのか？

実装レベルでは、イベント反応は、変化の存在を特徴付けるグラフの情報の伝搬で構成されています。その結果、そのような変化の影響を受ける計算が古くなり、再実行のためのフラグを立てる必要がある。このような計算は、通常、関連するソースにおける変化の推移的閉鎖によって特徴づけられる。変更の伝播は、その後、グラフのシンクの値の更新につながる可能性がある。

グラフ伝播された情報は、ノードの完全な状態、すなわち、関係するノードの計算結果で構成され得る。このような場合、ノードの以前の出力は無視される。もう一つの方法は、デルタ伝搬、すなわちインクリメンタルな変化伝搬である。この場合、情報はグラフのエッジに沿って伝播され、エッジは前のノードがどのように変更されたかを記述するデルタのみで構成されます。この方法は、ノードが大量の状態データを保持している場合に特に重要であり、そうでなければゼロから再計算するのは高くつく。

デルタ伝搬は、基本的にインクリメンタルコンピューティングの分野で広く研究されてきた最適化であり、そのアプローチにはビューアップデート問題を含む実行時の満足度が必要です。この問題は、変更されるデータビューの保守を担当するデータベースエンティティの使用によって特徴づけられることが悪名高い。

もう一つの一般的な最適化は、単項の変更累積とバッチ伝搬の採用である。このようなソリューションは、関係するノード間の通信を減らすことができるため、より高速に処理することができます。例えば、バッチ内の2つの変更は互いにキャンセルされるため、単に無視されることがあります。さらに別の利用可能なアプローチとして、無効通知伝播（invalidity notification propagation）というものがある。このアプローチは、無効な入力を持つノードに更新をプルさせ、その結果、彼ら自身の出力が更新される。

依存関係グラフの構築には、主に2つの方法が採用されています。

- 依存関係グラフは、イベントループの中で暗黙のうちに維持されます。明示的なコールバックを登録することで、暗黙の依存関係が生成される。したがって、コールバックを介して誘導される制御の逆転は、このようにそのまま残される。しかし、コールバックを機能的にする（ユニット値の代わりに状態値を返す）には、そのようなコールバックを構成的にすることが必要である。
- 依存関係のグラフは、プログラム固有であり、プログラマによって生成される。これは、2つの方法でコールバックの制御反転の対処を容易にする：グラフが明示的に指定されるか（典型的にはドメイン固有言語（DSL）を使用し、埋め込まれるかもしれない）、またはグラフが効果的で典型的な言語を使用して表現および生成によって暗黙的に定義される。

## リアクティブプログラミングにおける実装上の課題

### Glitches

変更を伝播する際、式の値がソースプログラムの自然な結果ではないような伝播順序を選択することが可能です。このことは、例で簡単に説明することができます。例えば、secondsが1秒ごとに変化して現在の時刻（秒）を表すリアクティブな値であるとします。この式を考えてみましょう。

```c
t = seconds + 1
g = (t > seconds)
```

tは常にsecondsより大きいはずなので、この式は常に真値で評価されるはずです。しかし、残念ながら、これは評価の順序に依存することがあります。secondsが変化すると、seconds + 1と条件式という2つの式が更新されることになります。もし、前者が後者より先に評価されれば、この不変性は維持されます。しかし、条件式が先に更新され、古い値であるtと新しい値であるsecondsが使用されると、式は偽の値に評価されることになります。これをグリッチと呼ぶ。

リアクティブ言語の中にはグリッチフリーのものがあり、この性質を証明している[citation needed]。これは通常、式をトポロジカルにソートし、トポロジカルな順序で値を更新することで実現される。しかし、これは（伝搬順序の関係で）値の配信が遅れるなど、パフォーマンスに影響を及ぼす可能性がある。そのため、リアクティブ言語では不具合が発生しやすく、値が一時的にプログラムソースと一致しなくなる可能性や、式が複数回評価される可能性（例えば、t > secondsは、秒の新しい値が到着したときと、tが更新されたときに2回評価される可能性）を開発者が意識する必要がある。

### Cyclic dependencies

依存関係のトポロジーソートは、依存関係グラフが有向無サイクルグラフ（DAG）であることに依存します。実際には、プログラムは、サイクルを持つ依存関係グラフを定義することができる。通常、反応型プログラミング言語は、反応型更新を終了させるために、「バックエッジ」に沿って何らかの要素を配置することによって、このようなサイクルを「壊す」ことを期待している。通常、言語は、遅延のような演算子を提供し、この目的のために更新メカニズムによって使用される。

### ミュータブルステートとの相互作用

リアクティブ言語は、通常、表現が純粋に関数的であることを前提としています。これにより、更新機構は、更新を実行する順序を選択し、特定の順序を指定しないようにすることができます（これにより、最適化が可能になります）。しかし、リアクティブ言語が状態を持つプログラミング言語に組み込まれた場合、プログラマがミュータブルな操作を行う可能性がある。この相互作用をどのようにスムーズにするかは、まだ未解決の問題である。

場合によっては、原則的な部分解を持つことが可能です。そのような解決策として、以下の2つが挙げられる。

- ある言語には、「ミュータブルセル」という概念がある。ミュータブル・セルとは、リアクティブ・アップデート・システムが認識するセルであり、そのセルに加えられた変更はリアクティブ・プログラムの残りの部分に伝搬される。これにより、プログラムの非反応的な部分が従来の突然変異を実行する一方で、反応的なコードがこの更新を認識して応答することが可能になり、プログラム内の値間の関係の一貫性が維持される。このようなセルを提供するリアクティブ言語の例として、FrTimeがある[2]。
- 適切にカプセル化されたオブジェクト指向ライブラリは、状態の概念をカプセル化して提供する。したがって、原理的には、このようなライブラリは、言語のリアクティブな部分とスムーズに相互作用することが可能である。例えば、オブジェクト指向ライブラリのゲッターにコールバックを設置して、状態の変化をリアクティブな更新エンジンに通知したり、リアクティブなコンポーネントの変更をゲッターを通じてオブジェクト指向ライブラリにプッシュすることができる。FrTimeはこのような戦略を採用している[3]。

### 依存関係グラフの動的更新

リアクティブ言語の中には、依存関係のグラフが静的なもの、つまり、プログラムの実行中ずっと固定されているものがあります。他の言語では、グラフは動的であり、プログラムの実行に伴って変化することがある。簡単な例として、次のような例を考えてみましょう（ここで、秒は反応値です）。

```c
t =
  if ((seconds mod 2) == 0):
    seconds + 1
  else:
    seconds - 1
  end
t + 1
```

毎秒、この式の値は異なる反応式に変化し、t + 1はそれに依存する。したがって、依存関係のグラフは1秒ごとに更新される。

依存関係の動的更新を許可することで、大きな表現力を得ることができる（例えば、グラフィカルユーザーインターフェイス（GUI）プログラムでは、動的依存関係が日常的に発生する）。しかし、反応型更新エンジンは、毎回式を再構築するか、式のノードを構築したまま非アクティブにしておくか、後者の場合、アクティブであるべきでないときに計算には参加しないようにするかを決定しなければならない。

## Concepts

### エクスキューズの程度

リアクティブプログラミング言語には、矢印を使ってデータフローを設定する非常に明示的なものから、命令型プログラミングや関数型プログラミングに似た言語構成からデータフローを導き出す暗黙的なものまであります。例えば、暗黙のうちに持ち上がる関数型反応プログラミング（FRP）では、関数呼び出しによって暗黙のうちにデータフローグラフのノードが構築されることがあります。動的言語用のリアクティブプログラミングライブラリ（Lispの「Cells」やPythonの「Trellis」ライブラリなど）は、関数の実行中に読み込まれた値の実行時分析から依存関係グラフを構築できるため、データフローの仕様を暗黙的かつ動的にすることができる。

リアクティブプログラミングという言葉は、ソフトウェア工学のアーキテクチャレベルを指すこともあり、データフローグラフの個々のノードは、互いに通信する通常のプログラムである。

### Static or dynamic

リアクティブ・プログラミングには、データフローを静的に設定する静的プログラミングと、プログラムの実行中にデータフローを変化させる動的プログラミングがあります。

データフローグラフにデータスイッチを使用することで、静的なデータフローグラフをある程度動的なものに見せることができ、その区別は若干曖昧になります。しかし、真の動的反応プログラミングでは、命令型プログラミングを使ってデータフロー・グラフを再構築することができる。

### Higher-order reactive programming

データフローを利用して他のデータフローを構築することができるという考え方を支持するのであれば、リアクティブプログラミングはより高次のものであると言える。つまり、あるデータフローから得られる値は、最初のデータフローと同じ評価モデルで実行される別のデータフロー・グラフである。

### Data flow differentiation

理想的には、すべてのデータ変更が即座に伝搬されることが望ましいが、実際にはこれを保証することはできない。その代わりに、データフロー・グラフの異なる部分に異なる評価の優先順位を与えることが必要になる場合がある。これは、分化型リアクティブプログラミングと呼ばれるものである[4]。

例えば、ワードプロセッサーでは、スペルミスのチェックが文字の挿入と完全に同期している必要はない。そこで、スペルチェッカーの優先順位を下げ、他のデータフローを瞬時に処理する一方でスペルチェッカーを遅延させる、差別化されたリアクティブプログラミングを用いることが考えられる。

しかし、このような差別化を行うと、設計の複雑さが増す。例えば、異なるデータフロー領域をどのように定義するか、異なるデータフロー領域間のイベントパッシングをどのように処理するか、などである。

### リアクティブプログラミングの評価モデル

リアクティブプログラムの評価は、必ずしもスタックベースのプログラミング言語の評価方法に基づいているわけではありません。その代わり、あるデータが変更されると、その変更は、変更されたデータから部分的または完全に派生するすべてのデータに伝搬される。この変更の伝播には様々な方法があるが、最も自然な方法は、無効化/遅延検証スキームであろう。

データ構造がある形状をしている場合、指数関数的な更新の複雑さが生じる可能性があるため、単純にスタックを使用して変更を伝播することは問題である可能性がある。そのような形状の1つは、「繰り返されるダイヤモンドの形」と表現され、次のような構造を持っています。An→Bn→An+1、An→Cn→An+1、ここでn=1,2...。この問題は、あるデータがまだ無効化されていない場合にのみ無効化を伝播させ、必要なときに遅延評価を用いてデータを再認識することで克服することができる。

リアクティブ・プログラミングの本質的な問題として、通常のプログラミング言語では評価されて忘れ去られてしまうような計算を、データ構造としてメモリ上で表現する必要があることが挙げられる[citation needed]。これは、リアクティブ・プログラミングを非常にメモリ消費型にする可能性がある。しかし、低次元化と呼ばれる研究により、この問題を克服できる可能性がある[5]。

一方、リアクティブプログラミングは、「明示的並列処理」[citation needed]と表現できるものであり、並列ハードウェアのパワーを活用する上で有益であると考えられる。

#### オブザーバーパターンとの類似性

データ構造がある形状をしている場合、指数関数的な更新の複雑さが生じる可能性があるため、単純にスタックを使用して変更を伝播することは問題である可能性がある。そのような形状の1つは、「繰り返されるダイヤモンドの形」と表現され、次のような構造を持っています。An→Bn→An+1、An→Cn→An+1、ここでn=1,2...。この問題は、あるデータがまだ無効化されていない場合にのみ無効化を伝播させ、必要なときに遅延評価を用いてデータを再認識することで克服することができる。

## Approaches

### Imperative

リアクティブプログラミングは、通常の命令型プログラミングと融合させることができる。このようなパラダイムでは、命令型プログラムが反応型データ構造を操作する[6]。このような設定は命令型制約プログラミングに類似しているが、命令型制約プログラミングが双方向のデータフロー制約を管理するのに対し、命令型反応プログラミングは片方向のデータフロー制約を管理する。

### Object-oriented

オブジェクト指向リアクティブプログラミング（OORP）とは、オブジェクト指向プログラミングとリアクティブプログラミングを組み合わせたものである。おそらく、このような組み合わせを行う最も自然な方法は以下の通りである：メソッドとフィールドの代わりに、オブジェクトは、それらが依存している他の反応が変更されたときに自動的に再評価する反応を有する[citation needed] 。

OORP言語が命令型メソッドを維持していれば、命令型リアクティブプログラミングのカテゴリーにも入る。

### Functional

Functional Reactive Programming（FRP）は、関数型プログラミングをベースにしたリアクティブプログラミングのためのプログラミングパラダイムです。

### アクターベース (Actor based)

リアクティブシステムを設計するためにアクターが提案されており、多くの場合、機能的リアクティブプログラミング（FRP）と組み合わせて、分散リアクティブシステムを開発している[7][8]。

### ルールベース (Rule based)

比較的新しいカテゴリーのプログラミング言語では、制約（ルール）を主要なプログラミング概念として使用しています。これは、イベントに対する反応から構成され、すべての制約を満足させるものである。これは、イベントベースの反応を容易にするだけでなく、リアクティブプログラムがソフトウェアの正しさに貢献するものである。ルールベースのリアクティブプログラミング言語の例として、関係代数に基礎を置くAmpersandがある[9]。

## 導入事例

- ReactiveXは、ストリーム、オブザーバブル、演算子によるリアクティブプログラミングを実装するためのAPIで、RxJs、- RxJava、Rx.NET、RxPy、RxSwiftなど複数の言語実装があります。
- Elm（プログラミング言語） Webユーザーインターフェイスのリアクティブコンポジション。
- Reactive Streams、ノンブロッキングバックプレッシャーによる非同期ストリーム処理のためのJVMスタンダード
- ObservableComputations、クロスプラットフォームな.NET実装です。
- Svelteは、JavaScriptのように見えるが、通常JavaScriptが反応しない部分を自然に反応させる、変形JavaScript構文の形で反応性をもたらすものである。
- Solid.jsは、JavaScriptの構文のセマンティクスを変更することなく、JavaScriptに反応性をもたらし、反応性の高いJSXテンプレートも提供します。

## See also

